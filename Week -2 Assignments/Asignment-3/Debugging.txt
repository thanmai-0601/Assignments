Insurance Customer Analytics – Debugging Exercise

## Bug 1: Loop Output Issue

Problem:
The loop condition uses '<= customers.length', which accesses an invalid index (out of bounds).

Fix:
for (let i = 0; i < customers.length; i++) {
  console.log(customers[i].name);
}

Explanation:
Array indexes go from 0 to length − 1, so the condition must be '<' instead of '<='.

---

## Bug 2: filter() Not Working

Problem:
The callback function does not return any value.

Fix:
const activeCustomers = customers.filter((c) => {
  return c.active === true;
});

Explanation:
'filter()' keeps elements only when the callback returns 'true'.

---

## Bug 3: Premium Increase Logic Broken

Problem:
'map()' does not return anything and mutates the original object.

Fix:
const updatedPremiums = customers.map((c) => {
  if (c.age >= 50) {
    return { ...c, premium: c.premium * 1.1 };
  }
  return c;
});


Explanation:
'map()' must return a value for every element, and immutability should be preserved by creating a copy.

---

## Bug 4: Wrong Total Premium Calculation

Problem:
'reduce()' callback does not return the updated accumulator.

Fix:
const totalPremium = customers.reduce((total, c) => {
      return total + c.premium;
}, 0);

Explanation:
'reduce()' requires returning the accumulator in each iteration.

---

## Bug 5: Template Literal Not Printing

Problem:
Template literals require backticks, not double quotes.

Fix:
console.log(`Customer ${customers[0].name} has policy ${customers[0].policy}`);

Explanation:
`${}` works only inside backticks.

---

## Bug 6: Policy Count Incorrect

Problem:
Uses the literal key "policy" instead of the actual policy name.

Fix:
const policyCount = customers.reduce((count, c) => {
  count[c.policy] = (count[c.policy] || 0) + 1;
  return count;
}, {});

Explanation:
Bracket notation allows dynamic object keys.

---

## Bug 7: Risk Level Always Wrong

Problem:
Conditions override each other because of incorrect 'if' structure.

Fix:
if (c.age < 35) riskLevel = "Low";
else if (c.age <= 50) riskLevel = "Medium";
else riskLevel = "High";

Explanation:
'else if' ensures only one condition runs.

---

## Bug 8: Active vs Inactive Count Wrong

Problem:
'for...in' iterates over indexes, not objects.

Fix:
for (const c of customers) {
  if (c.active) active++;
  else inactive++;
}

Explanation:
'for...of' iterates over array elements (objects).

---

## Bug 9: Arrow Function Syntax Error

Problem:
Multiline arrow function without 'return'.

Fix:
const getLifeCustomers = () =>
  customers.filter(c => c.policy === "Life").map(c => c.name);

Explanation:
Only single-line arrow functions return implicitly.

---

## Bug 10: Sorting Mutates Original Array

Problem:
'sort()' mutates the original array.

Fix:
const sortedCustomers = [...customers].sort((a, b) => b.premium - a.premium);

Explanation:
The spread operator creates a copy, preserving immutabilities.